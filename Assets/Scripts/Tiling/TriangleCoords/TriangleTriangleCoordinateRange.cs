using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using Unity.Mathematics;
using UnityEngine;

namespace Assets.Tiling.TriangleCoords
{

    /// <summary>
    /// represents a range of triangular coordinates in a triangular shape
    /// </summary>
    [System.Serializable]
    [StructLayout(LayoutKind.Explicit)] // total size: 16 bytes
    public struct TriangleTriangleCoordinateRange : ICoordinateRange<TriangleCoordinate>, IEquatable<TriangleTriangleCoordinateRange>
    {
        [FieldOffset(0)] public TriangleCoordinate root;
        [FieldOffset(12)] public int triangleSideLength;

        public IEnumerable<Vector2> BoundingPolygon()
        {
            var scale = 2;

            var nextPos = root.ToPositionInPlane();
            yield return nextPos - (TriangleCoordinate.rBasis * scale);

            var topCoord = new TriangleCoordinate(root.u, root.v + triangleSideLength - 1, false);
            nextPos = topCoord.ToPositionInPlane();
            yield return (Vector2)nextPos + Vector2.up * TriangleCoordinate.rBasis.y * 2 * scale;

            var rightcoord = new TriangleCoordinate(root.u + triangleSideLength - 1, root.v, false);
            nextPos = rightcoord.ToPositionInPlane();
            yield return (Vector2)nextPos + Vector2.Scale(new Vector2(1, -1), TriangleCoordinate.rBasis * scale);
        }
        public IEnumerable<TriangleCoordinate> BoundingCoordinates()
        {
            yield return root;
            yield return new TriangleCoordinate(root.u, root.v + triangleSideLength - 1, false);
            yield return new TriangleCoordinate(root.u + triangleSideLength - 1, root.v, false);
        }
        public int[] BoundingPolyTriangles => new int[] { 0, 1, 2 };

        IEnumerator<TriangleCoordinate> IEnumerable<TriangleCoordinate>.GetEnumerator()
        {
            var maxIndex = triangleSideLength - 1;
            for (var u = maxIndex; u >= 0; u--)
            {
                var vMax = maxIndex - u;
                for (var v = 0; v < vMax; v++)
                {
                    yield return new TriangleCoordinate(u + root.u, v + root.v, false);
                    yield return new TriangleCoordinate(u + root.u, v + root.v, true);
                }
                // v == vMax
                yield return new TriangleCoordinate(u + root.u, vMax + root.v, false);
            }
        }

        public static TriangleTriangleCoordinateRange From(TriangleCoordinate root, int sideLength)
        {
            return new TriangleTriangleCoordinateRange
            {
                root = root,
                triangleSideLength = sideLength
            };
        }

        /// <summary>
        /// maps an index to a triange coordinate, lining up with the order which would be generated by the enumerator
        /// worked out in https://docs.google.com/spreadsheets/d/1ECaP2QyAdnKA3EAwqt9qFnG9sfGvA6wx_1kv7QG2mis/edit
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public TriangleCoordinate AtIndex(int index)
        {
            var resultStruct = new TriangleCoordinate();
            var maxUMinusU = (int)math.floor(math.sqrt(index));
            var maxU = triangleSideLength - 1;
            resultStruct.u = maxU - maxUMinusU;

            var indexInU = index - (maxUMinusU * maxUMinusU);
            resultStruct.R = (indexInU % 2) == 1;
            resultStruct.v = indexInU / 2;

            resultStruct.u += root.u;
            resultStruct.v += root.v;
            return resultStruct;
        }

        public bool ContainsCoordinate(UniversalCoordinate universalCoordinate)
        {
            if (universalCoordinate.type != CoordinateType.TRIANGLE)
            {
                return false;
            }
            return ContainsCoordinate(universalCoordinate.triangleDataView);
        }
        public bool ContainsCoordinate(TriangleCoordinate coordinate)
        {
            var uConst = coordinate.u - root.u;
            var vConst = coordinate.v - root.v;
            var constConst = uConst + vConst + (coordinate.R ? 0 : -1);
            return uConst >= 0 && vConst >= 0 && constConst < triangleSideLength;
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return (this as IEnumerable<TriangleCoordinate>).GetEnumerator();
        }

        public int TotalCoordinateContents()
        {
            return triangleSideLength * triangleSideLength;
        }

        public bool Equals(TriangleTriangleCoordinateRange other)
        {
            return root.Equals(other.root) && triangleSideLength == other.triangleSideLength;
        }
    }
}
